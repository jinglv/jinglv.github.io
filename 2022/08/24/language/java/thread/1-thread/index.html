<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jinglv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习Java多线程学习笔记第一讲">
<meta property="og:type" content="article">
<meta property="og:title" content="Java之多线程">
<meta property="og:url" content="https://jinglv.github.io/2022/08/24/language/java/thread/1-thread/index.html">
<meta property="og:site_name" content="Jean&#39;s Blog">
<meta property="og:description" content="学习Java多线程学习笔记第一讲">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081018028.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081018176.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081019023.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081019362.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081020124.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081020450.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081020762.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081021496.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081024734.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081022047.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081024172.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081025956.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081026316.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081026614.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081027061.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081027447.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081032120.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081028667.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081028313.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081029999.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081029912.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081029129.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081030950.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081030856.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081031869.png">
<meta property="article:published_time" content="2022-08-23T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-24T05:30:00.000Z">
<meta property="article:author" content="Jean Lv">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081018028.png">

<link rel="canonical" href="https://jinglv.github.io/2022/08/24/language/java/thread/1-thread/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java之多线程 | Jean's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Jean's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jean's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注软件测试开发技术的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jinglv.github.io/2022/08/24/language/java/thread/1-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jean Lv">
      <meta itemprop="description" content="涉猎的主要编程语言Java、Python, 领域软件测试、AI测试开发相关">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jean's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java之多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-24 00:00:00 / 修改时间：13:30:00" itemprop="dateCreated datePublished" datetime="2022-08-24T00:00:00+08:00">2022-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <div class="post-description">学习Java多线程学习笔记第一讲</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java之多线程"><a href="#Java之多线程" class="headerlink" title="Java之多线程"></a>Java之多线程</h1><h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>打开Windows任务管理器，可以发现我们在操作系统上运行的程序都是进程：</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081018028.png" alt="image-20230908101815880"></p>
<p><strong>进程的定义</strong>：进程是程序的⼀次执⾏，进程是⼀个程序及其数据在处理机上顺序执⾏时所发⽣的活动，进程是具有独⽴功能的程序在⼀个数据集合上运⾏的过程，它是系统进⾏资源<strong>分配和调度的⼀个独⽴单位</strong>。</p>
<p><strong>进程是系统进行资源分配和调度的独立单位。每一个进程都要它自己的内存空间和系统资源。</strong></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程已经是可以进行资源分配和调度了，为什么还要<strong>线程</strong>呢？是为了使程序并发执行，系统必须执行以下的一系列操作：</p>
<ul>
<li><strong>创建进程</strong>：系统在创建一个进程时，必须为它分配其所必须的、除处理机以外的所有资源，如内存空间、I/O设备，以及建立相应的PCB（进程控制块：Process Control Block）<ul>
<li>PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。PCB的作用是使一个在<strong>多道程序</strong>环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。</li>
<li>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。与之相对应的是单道程序，即在计算机内存中只允许一个的程序运行。对于一个单CPU系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU上运行的程序只有一个。</li>
</ul>
</li>
<li><strong>撤销进程</strong>：系统在撤销进程时，又必须先对其所占有的资源执行回收操作，然后再撤销PCB</li>
<li><strong>进程切换</strong>：对进程进行上下文切换时，需要保存当前进程的CPU环境，设置新选中进程的CPU环境，因而须花费不少的处理机时间</li>
</ul>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081018176.png" alt="image-20230908101846011"></p>
<p>可以看到进程实现多处理机环境下的进程调度，分派，切换时， 都需要花费较⼤的时间和空间开销。</p>
<p>引⼊线程主要是为了<strong>提⾼系统的执⾏效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理</strong>。 使OS具有更好的并发性。</p>
<p>简单来说： 进程实现多处理⾮常耗费CPU的资源，⽽我们引⼊<strong>线程是作为调度和分派的基本单位</strong>（取代进程的部分基本功能【<strong>调度</strong>】 ）。</p>
<p>线程在哪呢？例如：打开一个音乐播放器，既能播放音乐，点击音乐播放器点击控件还能响应</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081019023.png" alt="image-20230908101912883" style="zoom:50%;" /></p>
<p>在同一个进程内可以执行多个任务，而这每一个任务都可以看出是一个线程。则<strong>一个进程会有一个或多个线程</strong>。</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li>进程作为资源<strong>分配</strong>的基本单位</li>
<li>线程作为资源<strong>调度</strong>的基本单位，<strong>是程序的执行单元，执行路径</strong>（单线程：一条执行路径，多线程：多条执行路径）。是程序使用CPU的最基本单位。</li>
</ul>
<p>线程有<strong>三个基本状态</strong>：执行、就绪、阻塞</p>
<p>线程有<strong>五种基本操作</strong>：派生、阻塞、激活、调度、结束</p>
<p><strong>线程的属性</strong>：</p>
<ul>
<li>轻型实体</li>
<li>独立调度和分派的基本单位</li>
<li>可并发执行</li>
<li>共享进程资源</li>
</ul>
<p>线程有两个<strong>基本类型</strong>：</p>
<ul>
<li><strong>用户级线程</strong>：管理过程全部由⽤户程序完成， <strong>操作系统内核⼼只对进程进⾏管理</strong>。</li>
<li><strong>系统级线程</strong>（核心级线程）：<strong>由操作系统内核进⾏管理</strong>。操作系统内核给应⽤程序提供相应的系统<br>调⽤和应⽤程序接⼝API，以使⽤户程序可以创建、执⾏以及撤消线程。</li>
</ul>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081019362.png" alt="image-20230908101939225"></p>
<p>多线程的存在，不是提高程序的执行速度，是为了<strong>提供应用程序的使用率</strong>，程序的执行其实都是在抢<strong>CPU的资源</strong>和<strong>CPU的执行权</strong>。多个进程时在抢这个资源，<strong>而其中的某一个进程如果执行路径比较多</strong>，就会有<strong>更高的几率</strong>抢到CPU的执行权。</p>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul>
<li>并行<ul>
<li>并⾏性是指<strong>同⼀时刻</strong>内发⽣两个或多个事件</li>
<li>并⾏是在<strong>不同</strong>实体上的多个事件</li>
</ul>
</li>
<li>并发<ul>
<li>并发性是指<strong>同⼀时间间隔内</strong>发⽣两个或多个事件</li>
<li>并发是在<strong>同⼀实体</strong>上的多个事件</li>
</ul>
</li>
</ul>
<p>并⾏是针对进程的， <strong>并发是针对线程的</strong></p>
<h2 id="Java实现多线程"><a href="#Java实现多线程" class="headerlink" title="Java实现多线程"></a>Java实现多线程</h2><p>Java实现多线程是使用了Thread这个类，主要看下Thread类的解释（注释）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java</span></span><br><span class="line"><span class="comment"> * Virtual Machine allows an application to have multiple threads of</span></span><br><span class="line"><span class="comment"> * execution running concurrently.-- JVM允许多个线程并发执行</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Every thread has a priority. Threads with higher priority are</span></span><br><span class="line"><span class="comment"> * executed in preference to threads with lower priority.--线程有优先级，优先级高的会比低的先要执行 Each thread</span></span><br><span class="line"><span class="comment"> * may or may not also be marked as a daemon--线程可能还会有守护（后台）线程. When code running in</span></span><br><span class="line"><span class="comment"> * some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new</span></span><br><span class="line"><span class="comment"> * thread has its priority initially set equal to the priority of the</span></span><br><span class="line"><span class="comment"> * creating thread, and is a daemon--初始化的时候，优先级都是平等的 thread if and only if the</span></span><br><span class="line"><span class="comment"> * creating thread is a daemon.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When a Java Virtual Machine starts up, there is usually a single</span></span><br><span class="line"><span class="comment"> * non-daemon thread (which typically calls the method named</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual</span></span><br><span class="line"><span class="comment"> * Machine continues to execute threads until either of the following</span></span><br><span class="line"><span class="comment"> * occurs:--JVM启动时，通常会有一个叫做main线程启动起来，它没有后台（守护线程）的</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been</span></span><br><span class="line"><span class="comment"> *     called and the security manager has permitted the exit operation</span></span><br><span class="line"><span class="comment"> *     to take place.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;All threads that are not daemon threads have died, either by</span></span><br><span class="line"><span class="comment"> *     returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by</span></span><br><span class="line"><span class="comment"> *     throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *     method.</span></span><br><span class="line"><span class="comment"> *		线程结束有这两种情况：</span></span><br><span class="line"><span class="comment"> *		1.执行退出exit方法</span></span><br><span class="line"><span class="comment"> *		2.run方法执行完或者抛出了异常</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * There are two ways to create a new thread of execution.--两个方法创建新的线程 One is to</span></span><br><span class="line"><span class="comment"> * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This</span></span><br><span class="line"><span class="comment"> * subclass should override the &lt;code&gt;run&lt;/code&gt; method of class</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be</span></span><br><span class="line"><span class="comment"> * allocated and started. For example, a thread that computes primes</span></span><br><span class="line"><span class="comment"> * larger than a stated value could be written as follows:</span></span><br><span class="line"><span class="comment"> * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt; -- 例子，继承Thread类，重写run方法</span></span><br><span class="line"><span class="comment"> *     class PrimeThread extends Thread &#123;</span></span><br><span class="line"><span class="comment"> *         long minPrime;</span></span><br><span class="line"><span class="comment"> *         PrimeThread(long minPrime) &#123;</span></span><br><span class="line"><span class="comment"> *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         public void run() &#123;</span></span><br><span class="line"><span class="comment"> *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment"> *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     PrimeThread p = new PrimeThread(143);</span></span><br><span class="line"><span class="comment"> *     p.start(); -- 启动线程</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The other way to create a thread is to declare a class that</span></span><br><span class="line"><span class="comment"> * implements the &lt;code&gt;Runnable&lt;/code&gt; -- 另一个方式实现Runnable接口 interface. That class then</span></span><br><span class="line"><span class="comment"> * implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can</span></span><br><span class="line"><span class="comment"> * then be allocated, passed as an argument when creating</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other</span></span><br><span class="line"><span class="comment"> * style looks like the following:</span></span><br><span class="line"><span class="comment"> * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     class PrimeRun implements Runnable &#123;</span></span><br><span class="line"><span class="comment"> *         long minPrime;</span></span><br><span class="line"><span class="comment"> *         PrimeRun(long minPrime) &#123;</span></span><br><span class="line"><span class="comment"> *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         public void run() &#123; -- 实现Runable接口，重写run方法</span></span><br><span class="line"><span class="comment"> *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment"> *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     PrimeRun p = new PrimeRun(143);</span></span><br><span class="line"><span class="comment"> *     new Thread(p).start(); -- 启动线程</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Every thread has a name for identification purposes. More than</span></span><br><span class="line"><span class="comment"> * one thread may have the same name. If a name is not specified when</span></span><br><span class="line"><span class="comment"> * a thread is created, a new name is generated for it.--每个线程都有自己的名字，在创建的时候如果没有指定，会自动给它一个名字</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Unless otherwise noted, passing a &#123;<span class="doctag">@code</span> null&#125; argument to a constructor</span></span><br><span class="line"><span class="comment"> * or method in this class will cause a &#123;<span class="doctag">@link</span> NullPointerException&#125; to be</span></span><br><span class="line"><span class="comment"> * thrown.--不能将参数设置为null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Runnable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Runtime#exit(int)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #run()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><ul>
<li>继承Thread，重写run方法</li>
<li>实现Runnable接口，重写run方法</li>
<li>实现Callable接口，重写run方法</li>
</ul>
<h4 id="继承Thread，重写run方法"><a href="#继承Thread，重写run方法" class="headerlink" title="继承Thread，重写run方法"></a>继承Thread，重写run方法</h4><ul>
<li><p>创建一个类，继承Thread，重写run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>调用测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程对象</span></span><br><span class="line">        <span class="type">MyTread</span> <span class="variable">tread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTread</span>();</span><br><span class="line">        <span class="type">MyTread</span> <span class="variable">tread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTread</span>();</span><br><span class="line"></span><br><span class="line">        tread1.start();</span><br><span class="line">        tread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="实现Runnable接口，重写run方法"><a href="#实现Runnable接口，重写run方法" class="headerlink" title="实现Runnable接口，重写run方法"></a>实现Runnable接口，重写run方法</h4><ul>
<li><p>实现Runnable接口，重写run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>调用测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Runnable类的对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Java实现多线程需要注意的细节"><a href="#Java实现多线程需要注意的细节" class="headerlink" title="Java实现多线程需要注意的细节"></a>Java实现多线程需要注意的细节</h3><ul>
<li><strong>run()和start()方法区别</strong>：<ul>
<li><strong>run()</strong>:仅仅是<strong>封装被线程执行的代码</strong>，直接调用是普通方法</li>
<li><strong>start()</strong>:首先<strong>启动了线程</strong>，然后再由<strong>jvm去调用该线程的run()方法</strong></li>
</ul>
</li>
<li><strong>JVM虚拟机的启动是单线程还是多线程？</strong><ul>
<li><strong>多线程</strong>。不仅仅是启动main线程，还会至少启动垃圾回收线程，回收不用的内存</li>
</ul>
</li>
<li><strong>实现多线程，一般使用Runnable接口</strong><ul>
<li><strong>可以避免java中的单继承的限制</strong></li>
<li>应该将并发<strong>运行任务和运行机制解耦</strong>，因此选择实现Runnable接口这种方式</li>
</ul>
</li>
</ul>
<h2 id="Thread类解析"><a href="#Thread类解析" class="headerlink" title="Thread类解析"></a>Thread类解析</h2><h3 id="设置线程名"><a href="#设置线程名" class="headerlink" title="设置线程名"></a>设置线程名</h3><p><code>Thread.currentThread().getName()</code>查看线程名。</p>
<p>如果没有做什么设置，我们会发现线程的名字是这样：<strong>主线程叫做main，其他线程是Thread-x</strong></p>
<p>查看Thread类中线程是如何命名的：</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081020124.png" alt="image-20230908102007995"></p>
<p><code>nextThreadNum()</code>的方法是这样实现的：</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081020450.png" alt="image-20230908102028305"></p>
<p>在查看一下init方法：</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081020762.png" alt="image-20230908102055623" style="zoom:50%;" /></p>
<ul>
<li><p>实现了Runnable的方式来实现多线程，打印线程名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印出当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>调用测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Runnable类的对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 带参构造方法给线程起名字</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>执行结果</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081021496.png" alt="image-20230908102120363"></p>
</li>
</ul>
<p>还可以通过<code>setName(String name)</code>的方法来改掉线程的名字。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程是<strong>为其他线程服务的</strong>，<strong>垃圾回收线程就是守护线程</strong></p>
<p>守护线程有一个特点：</p>
<ul>
<li>当别的用户线程执行完了，虚拟机就会退出，守护线程也就会被停止掉了。也就是说：<strong>守护线程作为一个服务线程，没有服务对象就没有必要继续运行了</strong>。</li>
</ul>
<p>使用线程的时候要注意的地方：</p>
<ol>
<li>在线程启动前设置为守护线程，方法是<code>setDaemon(boolean on)</code></li>
<li>使用守护线程不要访问共享资源（数据库、文件等），因为它可能会在任何时候就挂掉了</li>
<li>守护线程中产生的新线程也是守护线程</li>
</ol>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Runnable类的对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 带参构造方法给线程起名字</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置守护线程</span></span><br><span class="line">        thread2.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程1和主线程执⾏完了，我们的守护线程就不执⾏了(电脑性能足够好的可能测不出来)</p>
<p>注意：要在线程<strong>启动之前</strong>设置守护线程，如果启动了再设置守护线程，会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Marks this thread as either a &#123;<span class="doctag">@linkplain</span> #isDaemon daemon&#125; thread</span></span><br><span class="line"><span class="comment">  * or a user thread. The Java Virtual Machine exits when the only</span></span><br><span class="line"><span class="comment">  * threads running are all daemon threads.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt; This method must be invoked before the thread is started.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  on</span></span><br><span class="line"><span class="comment">  *         if &#123;<span class="doctag">@code</span> true&#125;, marks this thread as a daemon thread</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span>  IllegalThreadStateException</span></span><br><span class="line"><span class="comment">  *          if this thread is &#123;<span class="doctag">@linkplain</span> #isAlive alive&#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">  *          if &#123;<span class="doctag">@link</span> #checkAccess&#125; determines that the current</span></span><br><span class="line"><span class="comment">  *          thread cannot modify this thread</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">     checkAccess();</span><br><span class="line">     <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     daemon = on;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先级线程"><a href="#优先级线程" class="headerlink" title="优先级线程"></a>优先级线程</h3><p>线程优先级高仅仅表示线程<strong>获取的CPU时间片的几率高</strong>，但这不是一个确定的因素！</p>
<p>线程的优先级的高度依赖于操作系统的，Windows和Linux就有所区别（Linux下优先级可能就被忽略了~）</p>
<p>Java提供的优先级默认是5，最低1，最高10</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>优先级的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Changes the priority of this thread.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called</span></span><br><span class="line"><span class="comment">  * with no arguments. This may result in throwing a</span></span><br><span class="line"><span class="comment">  * &lt;code&gt;SecurityException&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Otherwise, the priority of this thread is set to the smaller of</span></span><br><span class="line"><span class="comment">  * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted</span></span><br><span class="line"><span class="comment">  * priority of the thread&#x27;s thread group.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> newPriority priority to set this thread to</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@exception</span>  IllegalArgumentException  If the priority is not in the</span></span><br><span class="line"><span class="comment">  *               range &lt;code&gt;MIN_PRIORITY&lt;/code&gt; to</span></span><br><span class="line"><span class="comment">  *               &lt;code&gt;MAX_PRIORITY&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@exception</span>  SecurityException  if the current thread cannot modify</span></span><br><span class="line"><span class="comment">  *               this thread.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>        #getPriority</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>        #checkAccess()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>        #getThreadGroup()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>        #MAX_PRIORITY</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>        #MIN_PRIORITY</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>        ThreadGroup#getMaxPriority()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span> &#123;</span><br><span class="line">     ThreadGroup g;</span><br><span class="line">     checkAccess();</span><br><span class="line">     <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 参数检查，如果存在线程组，那么该线程的优先级不能比组的优先级要高</span></span><br><span class="line">     <span class="keyword">if</span>((g = getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">             newPriority = g.getMaxPriority();</span><br><span class="line">         &#125;</span><br><span class="line">         setPriority0(priority = newPriority);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>setPriority0是一个本地（navite）的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>之前介绍线程的线程有三个基本状态：执行、就绪、阻塞</p>
<p>查看如下图，Thread上有很多方法是用来切换线程状态的</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081024734.png" alt="image-20230908102416583" style="zoom:50%;" /></p>
<h4 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h4><p>调⽤sleep⽅法会进⼊计时等待状态，等时间到了， 进⼊的是就绪状态⽽并⾮是运⾏状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">   * execution) for the specified number of milliseconds, subject to</span></span><br><span class="line"><span class="comment">   * the precision and accuracy of system timers and schedulers.--受精确的时间约束 The thread</span></span><br><span class="line"><span class="comment">   * does not lose ownership of any monitors.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  millis 参数Long值，毫秒</span></span><br><span class="line"><span class="comment">   *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">   *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">   *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">   *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">   *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>加上Sleep后的状态图</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081022047.png" alt="image-20230908102209874"></p>
<h4 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h4><p>调用yield方法会先让别的线程执行，但是不确保真正让出</p>
<ul>
<li>意思：我有空，可以的话，让你们先执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A hint to the scheduler that the current thread is willing to yield</span></span><br><span class="line"><span class="comment">   * its current use of a processor. The scheduler is free to ignore this</span></span><br><span class="line"><span class="comment">   * hint.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span></span><br><span class="line"><span class="comment">   * between threads that would otherwise over-utilise a CPU. Its use</span></span><br><span class="line"><span class="comment">   * should be combined with detailed profiling and benchmarking to</span></span><br><span class="line"><span class="comment">   * ensure that it actually has the desired effect.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; It is rarely appropriate to use this method.--实际上很少用，它不确保一定会让出CPU It may be useful</span></span><br><span class="line"><span class="comment">   * for debugging or testing purposes, where it may help to reproduce</span></span><br><span class="line"><span class="comment">   * bugs due to race conditions. It may also be useful when designing</span></span><br><span class="line"><span class="comment">   * concurrency control constructs such as the ones in the</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> java.util.concurrent.locks&#125; package.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>加上yield后的状态图</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081024172.png" alt="image-20230908102456011" style="zoom:50%;" /></p>
<h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>调⽤join⽅法，会等待<strong>该线程</strong>执⾏<strong>完毕后才执⾏别的线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die. -- 等待这个线程死亡</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment"> * way as the invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #join(long) join&#125;&#123;<span class="doctag">@code</span> (0)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看<strong>join</strong>的具体实现</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081025956.png" alt="img" style="zoom:50%;" /></p>
<p>wait方法是Object上定义的，它是native本地方。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081026316.png" alt="image-20230908102646164"></p>
<p><strong>wait</strong>方法实际上它也是<strong>计时等待</strong>（如果带时间参数）的一种！</p>
<p>加上join后的状态图</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081026614.png" alt="image-20230908102621410" style="zoom:50%;" /></p>
<h4 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h4><p>线程终端，之前的版本是有stop方法，但被设置过时了。现在已经没有强制线程终止的方法了！</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081027061.png" alt="image-20230908102704885" style="zoom:50%;" /></p>
<p>由于stop方法可以让<strong>一个线程A终止掉另一个线程B</strong>。</p>
<ul>
<li>被终止的线程B会立即释放锁，这可能会让<strong>对象处于不一致的状态</strong></li>
<li><strong>线程A也不知道线程B什么时候能够被终⽌掉</strong>，万⼀线程B还处理运⾏计算阶段，线程A调⽤stop⽅<br>法将线程B终⽌，那就很⽆辜了</li>
</ul>
<p>总而言之，stop方法太暴力了，不安全，所以被设置过时了。</p>
<p>一般使用的是interrupt来请求终止线程：</p>
<ul>
<li><p>要注意的是：interrupt<strong>不会真正停</strong>止一个线程，它仅仅是给这个线程发了一个信号告诉它，它应该要结束了</p>
</li>
<li><p>也就是说：Java设计者实际上是<strong>想线程自己来终止</strong>，通过上面的<strong>信号</strong>，就可以判断处理什么业务了</p>
</li>
<li><p>具体到底中断还是继续运行，应该由<strong>被通知的线程自己处理</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 若未发生中断，就正常执行任务</span></span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      <span class="comment">// 正常任务代码……</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中断的处理代码……</span></span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>再次说明：调⽤interrupt()<strong>并不是要真正终⽌掉当前线程</strong>，仅仅是设置了⼀个中断标志。这个中断标志可以给我们⽤来判断<strong>什么时候该⼲什么活！</strong>什么时候中断<strong>由我们⾃⼰来决定</strong>，这样就可以<strong>安全地终⽌线程了</strong>！</p>
<p>查看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Interrupts this thread.--中断当前线程</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Unless the current thread is interrupting itself, which is</span></span><br><span class="line"><span class="comment">   * always permitted, the &#123;<span class="doctag">@link</span> #checkAccess() checkAccess&#125; method</span></span><br><span class="line"><span class="comment">   * of this thread is invoked, which may cause a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * SecurityException&#125; to be thrown.--只能自己调用中断的方法，不然会抛出安全异常</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 【&lt;p&gt; If this thread is blocked in an invocation of the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * Object#wait() wait()&#125;, &#123;<span class="doctag">@link</span> Object#wait(long) wait(long)&#125;, or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;<span class="doctag">@link</span> Object&#125;</span></span><br><span class="line"><span class="comment">   * class, or of the &#123;<span class="doctag">@link</span> #join()&#125;, &#123;<span class="doctag">@link</span> #join(long)&#125;, &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * #join(long, int)&#125;, &#123;<span class="doctag">@link</span> #sleep(long)&#125;, or &#123;<span class="doctag">@link</span> #sleep(long, int)&#125;,</span></span><br><span class="line"><span class="comment">   * methods of this class, then its interrupt status will be cleared and it</span></span><br><span class="line"><span class="comment">   * will receive an &#123;<span class="doctag">@link</span> InterruptedException&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span></span><br><span class="line"><span class="comment">   * then the channel will be closed, the thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">   * status will be set, and the thread will receive a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * java.nio.channels.ClosedByInterruptException&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; If this thread is blocked in a &#123;<span class="doctag">@link</span> java.nio.channels.Selector&#125;</span></span><br><span class="line"><span class="comment">   * then the thread&#x27;s interrupt status will be set and it will return</span></span><br><span class="line"><span class="comment">   * immediately from the selection operation, possibly with a non-zero</span></span><br><span class="line"><span class="comment">   * value, just as if the selector&#x27;s &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.】--Java设计者设置中断标志的目的是想由被通知的线程自己处理，而这些方法都阻塞掉了。 被阻塞掉的线程调用中断方法是不合理的（不允许中断已经阻塞的线程）【因为可能会造成中断无效】</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">   * status will be set. &lt;/p&gt; -- 上面的三种情况都不发生，才能将对应的标志位置换</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.--中断一个不活动的线程是没有意义的</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">   *          if the current thread cannot modify this thread</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">          checkAccess(); -- 检查是否有权限</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">          <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker; -- 是否阻塞的线程调用（如：sleep）</span><br><span class="line">          <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">              interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">              b.interrupt(<span class="built_in">this</span>); -- 如果是，抛出异常，将中断标志位改为【<span class="literal">false</span>】（一般会在<span class="keyword">catch</span>中再次修改）</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      interrupt0();-- 如果没有，就可以修改到标志位了（没有进入<span class="keyword">if</span>）</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>查看抛出的异常：InterruptedException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thrown when a thread is waiting, sleeping, or otherwise occupied,</span></span><br><span class="line"><span class="comment"> * and the thread is interrupted, either before or during the activity.</span></span><br><span class="line"><span class="comment"> * Occasionally a method may wish to test whether the current</span></span><br><span class="line"><span class="comment"> * thread has been interrupted, and if so, to immediately throw</span></span><br><span class="line"><span class="comment"> * this exception.  The following code can be used to achieve</span></span><br><span class="line"><span class="comment"> * this effect: -- 当线程正在执行sleep、wait方法时调用线程中断，就会抛出这个异常</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *  if (Thread.interrupted())  // Clears interrupted status!</span></span><br><span class="line"><span class="comment"> *      throw new InterruptedException();</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Frank Yellin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#wait()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#wait(long)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#wait(long, int)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Thread#sleep(long)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Thread#interrupted()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptedException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6700697376100628473L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an &lt;code&gt;InterruptedException&lt;/code&gt; with no detail  message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InterruptedException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an &lt;code&gt;InterruptedException&lt;/code&gt; with the</span></span><br><span class="line"><span class="comment">     * specified detail message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   s   the detail message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InterruptedException</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说：<strong>interrupt方法是不会对线程状态造成影响的，它仅仅设置一个标志位罢了</strong>。</p>
<p>interrupt线程中断还有另外<strong>两个方法（检查该线程是否被中断）：</strong></p>
<ul>
<li><p>静态方法interrupted() —&gt; 会清除中断标志位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests whether the current thread has been interrupted.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.--这个方法会清除中断标志位  In</span></span><br><span class="line"><span class="comment"> * other words, if this method were to be called twice in succession, the</span></span><br><span class="line"><span class="comment"> * second call would return false (unless the current thread were</span></span><br><span class="line"><span class="comment"> * interrupted again, after the first call had cleared its interrupted</span></span><br><span class="line"><span class="comment"> * status and before the second call had examined it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment"> * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment"> * returning false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span></span><br><span class="line"><span class="comment"> *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isInterrupted()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>实例方法isInterrupted() —&gt; 不会清除中断标志位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment"> * status&lt;/i&gt; of the thread is unaffected by this method.--这个方法不会影响中断标志位</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment"> * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment"> * returning false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span></span><br><span class="line"><span class="comment"> *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #interrupted()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果阻塞线程调用了interrupt()方法，那么会<strong>抛出异常</strong>，<strong>设置标志位为false，同时该线程会退出阻塞</strong>的。</p>
<p>案例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="comment">// 创建线程并启动</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(main.runnable);</span><br><span class="line">        System.out.println(<span class="string">&quot;This is main&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 在main线程中睡了3秒钟，因此我们去新的线程中执行了</span></span><br><span class="line">            <span class="comment">// 在main线程睡个3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;In main&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.在睡半秒的同事，main的线程的3秒钟过去了，main线程设置了该线程中断</span></span><br><span class="line">        <span class="comment">// 设置中断</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 2. 每次睡半秒钟才执行</span></span><br><span class="line">                <span class="comment">// 睡半秒，再执行</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(i++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 判断该阻塞线程是否还在</span></span><br><span class="line">            System.out.println(Thread.currentThread().isAlive());</span><br><span class="line">            <span class="comment">// 4. 抛出了异常，该阻塞的线程（睡半秒钟立马停止阻塞，在catch方法还在存活这）线程的中断标志位被修改为了false</span></span><br><span class="line">            <span class="comment">// 判断该线程的中断标志位状态</span></span><br><span class="line">            System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">            System.out.println(<span class="string">&quot;In Runnable&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081027447.png" alt="image-20230908102745261"></p>
<h2 id="使用多线程需要注意的问题"><a href="#使用多线程需要注意的问题" class="headerlink" title="使用多线程需要注意的问题"></a>使用多线程需要注意的问题</h2><h3 id="使用多线程遇到的问题"><a href="#使用多线程遇到的问题" class="headerlink" title="使用多线程遇到的问题"></a>使用多线程遇到的问题</h3><h4 id="1-1线程安全问题"><a href="#1-1线程安全问题" class="headerlink" title="1.1线程安全问题"></a>1.1线程安全问题</h4><p>多线程主要是为了提高我们应用<strong>程序的使用率</strong>。但同时，这会给我们带来很多安全问题！</p>
<p>如果我们在<strong>单线程</strong>中以”顺序”(串行-&gt;独占)的方式执行<strong>代码是没有任何问题</strong>的。但是到了多线程的环境下（并行），如果没有设计和控制得好，就会给我们带来很多<strong>意想不到的状况</strong>，也就是线程安全问题<strong>，因为在多线程的环境下，线程是</strong>交替执行<strong>的，一般他们会使用多个线程</strong>执行相同的代码<strong>。如果在此相同的代码里边有着</strong>共享的变量<strong>，或者一些</strong>组合操作，我们想要的<strong>正确</strong>结果就很容易出现了问题。</p>
<p>下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 买票过程，多个线程卖100张票</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TicketDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="comment">// 100张票</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 线程睡半秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sale: &quot;</span> + tickets--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketDemo</span> <span class="variable">ticketDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketDemo</span>();</span><br><span class="line">        <span class="comment">// 启动三个线程出售100张票</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketDemo);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketDemo);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketDemo);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081032120.png" alt="image-20230908103228911"></p>
<p>观察结果，发现多个线程卖到同一张票，这就是线程安全问题。正确的情况是，票一共只有100张，三个线程卖出的票只能100张，也就是三个线程卖出的票号是不能有重复的。</p>
<p>如果说：当多个线程访问某个类时候，这个类<strong>始终</strong>能表现出<strong>正确的行为</strong>，那么这个类就是线程安全的！</p>
<p>有个原则：<strong>能使用JDK提供的线程安全机制，就使用JDK的</strong>。</p>
<h4 id="1-2性能问题"><a href="#1-2性能问题" class="headerlink" title="1.2性能问题"></a>1.2性能问题</h4><p>使用多线程我们的目的就是为了提高应用程序的使用率，但是如果多线程的代码<strong>没有设计好</strong>的话，那未必会提高效率。<strong>反而降低了效率，甚至会造成死锁！</strong></p>
<p>还是以上面的线程安全问题的例子，这个例子线程是不安全的，现在要将该例子优化为线程安全，最简单的方式：使用JDK提供的内置锁synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jingLv</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 买票过程，多个线程卖100张票</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TicketDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="comment">// 100张票</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 线程睡半秒</span></span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sale: &quot;</span> + tickets--);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketDemo</span> <span class="variable">ticketDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketDemo</span>();</span><br><span class="line">        <span class="comment">// 启动三个线程出售100张票</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketDemo);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketDemo);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketDemo);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081028667.png" alt="image-20230908102813457"></p>
<p>观察结果，买票的号都是顺序的，没有出现重复的情况了，但是观察执行过程，会发现是执行完一条才会在执行下一条，是同步的过程。</p>
<p>虽然实现了线程安全了，这也会带来很<strong>严重的性能问题</strong>：</p>
<ul>
<li>每个条执行都得<strong>等待</strong>上一条执行完成才可以完成对应的操作</li>
</ul>
<p>这就导致了：我们完成了一个小小的功能，使用了多线程的目的是想要提高效率，但现在没有把握得当，却带来严重的性能问题！</p>
<p>在使用多线程的时候：更严重的时候还有<strong>死锁</strong>（程序卡主不动了）。</p>
<h3 id="对象的发布与逸出"><a href="#对象的发布与逸出" class="headerlink" title="对象的发布与逸出"></a>对象的发布与逸出</h3><p>定义发布和逸出：</p>
<ul>
<li><strong>发布（publish）</strong>使对象能够在当前作用域之外的代码中使用</li>
<li><strong>逸出（escape）</strong>当某个不应该发布的对象被发布了</li>
</ul>
<h4 id="2-1常见的逸出"><a href="#2-1常见的逸出" class="headerlink" title="2.1常见的逸出"></a>2.1常见的逸出</h4><p>常见<strong>逸出</strong>的有下面几种方式：</p>
<ul>
<li>静态逸出</li>
<li>public修改的get方法</li>
<li>方法参数传递</li>
<li>隐式的this</li>
</ul>
<h5 id="静态逸出"><a href="#静态逸出" class="headerlink" title="静态逸出"></a>静态逸出</h5><p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081028313.png" alt="image-20230908102842131"></p>
<h5 id="public修饰get方法"><a href="#public修饰get方法" class="headerlink" title="public修饰get方法"></a>public修饰get方法</h5><p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081029999.png" alt="image-20230908102903803"></p>
<h5 id="方法参数传递"><a href="#方法参数传递" class="headerlink" title="方法参数传递"></a>方法参数传递</h5><p>因为把对象传递过去给另外的方法，已经是逸出了~</p>
<h5 id="this逸出"><a href="#this逸出" class="headerlink" title="this逸出"></a>this逸出</h5><p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081029912.png" alt="image-20230908102931729"></p>
<p><strong>逸出就是本不应该发布对象的地方，把对象发布了</strong>。导致我们的<strong>数据泄露</strong>出去了，这就造成了一个<strong>安全隐患</strong>！</p>
<h4 id="2-2安全发布对象"><a href="#2-2安全发布对象" class="headerlink" title="2.2安全发布对象"></a>2.2安全发布对象</h4><p>安全发布对象有几种常见的方式：</p>
<ul>
<li><strong>在静态域中直接初始化</strong>：<code>public static Person = new Person()</code><ul>
<li>静态初始化由JVM在类的初始化阶段就执行了，JVM内部存在着同步机制，致使这种方式我们可以安全发布对象</li>
</ul>
</li>
<li>对应的引用保存到到<strong>volatile或者AtomicReferance引用中</strong><ul>
<li>保证了该对象的引用的可见性和原子性</li>
</ul>
</li>
<li><strong>由final修饰</strong><ul>
<li>该对象是不可变，那么线程就一定是安全的，所以是安全发布</li>
</ul>
</li>
<li><strong>由锁来保护</strong><ul>
<li>发布和使用的时候都需要加锁，这样才保证能够该对象不会逸出</li>
</ul>
</li>
</ul>
<h3 id="解决多线程遇到的问题"><a href="#解决多线程遇到的问题" class="headerlink" title="解决多线程遇到的问题"></a>解决多线程遇到的问题</h3><h4 id="3-1简述解决线程安全性的办法"><a href="#3-1简述解决线程安全性的办法" class="headerlink" title="3.1简述解决线程安全性的办法"></a>3.1简述解决线程安全性的办法</h4><p>使用多线程就一定要<strong>保证我们的线程是安全的</strong>，这只最重要的地方！</p>
<p>在Java中，一般会有下面这么几种办法来实现线程安全问题：</p>
<ul>
<li>无状态（没有共享变量）</li>
<li>final使该引用变量不可变（如果该对象引用也引用了其他的对象，那么无论是发布或者使用时都需要加锁）</li>
<li>加锁（内置锁，显示Lock锁）</li>
<li>使用JDK提供的类来实现线程安全<ul>
<li>原子性（例如：AtomicLong来实现原子性…）</li>
<li>容器（ConcurrentHashMap等等…）</li>
<li>……</li>
</ul>
</li>
<li>……等等</li>
</ul>
<h4 id="3-2原子性和可见性"><a href="#3-2原子性和可见性" class="headerlink" title="3.2原子性和可见性"></a>3.2原子性和可见性</h4><h5 id="3-2-1原子性"><a href="#3-2-1原子性" class="headerlink" title="3.2.1原子性"></a>3.2.1原子性</h5><p>在多线程中很多时候都是因为某个操作不是原子性的，使数据混乱出错。如果操作的<strong>数据是原子性</strong>的，那么就可以很大程度上避免了线程安全问题了！</p>
<p>例如：</p>
<ul>
<li>count++，先读取，后自增，在赋值。这是三个步骤，如果该操作是原子性的，那么就可以说是线程安全了（会没有中间的三步操作，一步到位【原子性】）</li>
</ul>
<p><strong>原子性</strong>就是执行<strong>某一操作是不可分割</strong></p>
<ul>
<li>count++操作，就不是一个原子性的操作，它是分成了三个步骤来实现这个操作的</li>
<li>JDK中atomic包提供实现原子性操作</li>
</ul>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081029129.png" alt="image-20230908102953879" style="zoom:50%;" /></p>
<p>也有人将其做成表格来分类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>Integer</th>
<th>Long</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>基本类型</td>
<td>AtomicInteger</td>
<td>AtomicLong</td>
<td>AtomicBoolean</td>
</tr>
<tr>
<td>数组类型</td>
<td>AtomicIntegerArray</td>
<td>AtomicLongArray</td>
<td>AtomicReferenceArray</td>
</tr>
<tr>
<td>属性原子修改器</td>
<td>AtomicIntegerFieldUpdater</td>
<td>AtomicLongFieldUpdater</td>
<td>AtomicReferenceFieldUpdater</td>
</tr>
</tbody>
</table>
</div>
<h5 id="3-2-2可见性"><a href="#3-2-2可见性" class="headerlink" title="3.2.2可见性"></a>3.2.2可见性</h5><p>可见性，Java提供了一个关键字：volatile</p>
<ul>
<li>可以简单认为：volatile是一种<strong>轻量级的同步机制</strong></li>
</ul>
<p>volatile经典总结：<strong>volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性</strong></p>
<p>将其拆开解释一下：</p>
<ul>
<li>保证<strong>该变量对所有线程的可见性</strong><ul>
<li>在多线程的环境下：当这个变量修改时，<strong>所有的线程都会知道变量被修改了</strong>，也就是所谓的“可见性”</li>
</ul>
</li>
<li>不保证原子性<ul>
<li>修改变量（赋值）实质上是在JVM中分了好几步，而<strong>在这几步内（从装载变量到修改），它是不安全的</strong>。</li>
</ul>
</li>
</ul>
<p>使用了volatile修饰的变量保证了三点</p>
<ul>
<li><strong>一旦完成写入，任何访问这个字段的线程将会得到最新的值</strong></li>
<li>在写入之前，<strong>会保证所有之前发生的事已经发生</strong>，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存</li>
<li><strong>volatile可以防止重排序</strong>（重排序指的就是：程序执行的时候，CPU、编译器可能会对执行顺序做一些调整，导致执行顺序并不是从上往下的。从而出现了一些意想不到的效果）。而如果声明了volatile，那么CPU、编译器就会知道这个<strong>变量是共享的</strong>，不会被缓存寄存器或者其他不可见的地方。</li>
</ul>
<p>一般来说，<strong>volatile大多用于标志位上（判断操作）</strong>，满足下面的条件才应该使用volatile修饰变量：</p>
<ul>
<li><p><strong>修改变量时不依赖变量的当前值</strong>（因为volatile是不保证原子性的）</p>
</li>
<li><p><strong>该变量不会纳入到不变性条件中</strong>（该变量是可变的）</p>
</li>
<li><strong>在访问变量的时候不需要加锁</strong>（加锁就没必要使用volatile这种轻量级同步机制了）</li>
</ul>
<h4 id="3-3线程封闭"><a href="#3-3线程封闭" class="headerlink" title="3.3线程封闭"></a>3.3线程封闭</h4><p>在多线程的环境下，只要<strong>不使用成员变量（不共享数据）</strong>，那么就不会出现线程安全的问题了。</p>
<p>如下的例子，所有的数据都是方法（栈封闭）上操作的，<strong>每个线程都拥有自己的变量，互不干扰！</strong></p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081030950.png" alt="image-20230908103026751"></p>
<p>在方法上操作，<strong>只要保证不要在栈（方法）上发布对象</strong>（每个变量的作用域仅仅停留在当前的方法上），那么我们的线程就是安全的。</p>
<p>线程封闭的另一个方法：<strong>ThreadLocal</strong>，使用这个类的API就可以<strong>保证每个线程自己独占一个变量</strong>。（ThreadLocal会单独介绍……）</p>
<h4 id="3-4不变性"><a href="#3-4不变性" class="headerlink" title="3.4不变性"></a>3.4不变性</h4><p><strong>不可变对象线程一定安全。</strong></p>
<p>共享的变量都是可变的，正由于是可变的才会出现线程安全问题。如果<strong>该状态是不可变的</strong>，那么<strong>随便多个线程访问都是没有问题的！</strong></p>
<p>Java提供了final修饰符给我们使用，final的身影我们可能见得比较多，但值得说明的是：</p>
<ul>
<li><strong>final仅仅是不能修改该变量的引用，但是引用里面的数据是可以修改的！</strong></li>
</ul>
<p>就好像下面的HashMap，用final修饰了。但是它仅仅保证了该对象引用hashMap变量所指向是不可变的，但是hashMap内部的数据是可变的，也就是说：可以add，remove等等操作到集合中~</p>
<ul>
<li><p>因此，仅仅只能够说明<strong>hashMap是一个不可变的对象引用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;Person&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>不可变的对象引用</strong>在使用的时候，还是需要<strong>加锁</strong>：</p>
<ul>
<li>或者把Person也设计成一个线程安全的类</li>
<li>因为内部的状态是可变的，不加锁或者Person不是线程安全类，操作都是有危险的！</li>
</ul>
<p>想要将对象设计成不可变对象，那么要满足下面三个条件：</p>
<ul>
<li><strong>对象创建后状态就不能修改</strong></li>
<li><strong>对象所有的域都是final修饰的</strong></li>
<li><strong>对象是正确创建的</strong>（没有this引用逸出）</li>
</ul>
<p>String在我们学习的过程中我们就知道它是⼀个<strong>不可变对象</strong>，但是它没有遵循第⼆点(对象所有的域都是final修饰的)，因为JVM在内部做了优化的。但是我们如果是要⾃⼰设计不可变对象，是需要满⾜三个条件的。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081030856.png" alt="image-20230908103051645" style="zoom:50%;" /></p>
<h4 id="3-5线程安全性委托"><a href="#3-5线程安全性委托" class="headerlink" title="3.5线程安全性委托"></a>3.5线程安全性委托</h4><p>很多时候我们要实现线程安全<strong>未必就需要自己加锁，自己来设计</strong>。</p>
<p>可以使用JDK给我们提供的对象来完成线程安全的设计：</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202309081031869.png" alt="image-20230908103129601" style="zoom:30%;" /></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/24/language/java/thread/2-lock/" rel="prev" title="Java之synchronize锁和lock锁">
      <i class="fa fa-chevron-left"></i> Java之synchronize锁和lock锁
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/28/language/java/object/" rel="next" title="Java之对象的O">
      Java之对象的O <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">Java之多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">什么是多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">1.1.4.</span> <span class="nav-text">并行与并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">Java实现多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">创建多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">继承Thread，重写run方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">实现Runnable接口，重写run方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.2.</span> <span class="nav-text">Java实现多线程需要注意的细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E7%B1%BB%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">Thread类解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D"><span class="nav-number">1.3.1.</span> <span class="nav-text">设置线程名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">优先级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.4.</span> <span class="nav-text">线程生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">sleep方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#yield%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">yield方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">join方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#interrupt%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">interrupt方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">使用多线程需要注意的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用多线程遇到的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1.1线程安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">1.2性能问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E9%80%B8%E5%87%BA"><span class="nav-number">1.4.2.</span> <span class="nav-text">对象的发布与逸出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1%E5%B8%B8%E8%A7%81%E7%9A%84%E9%80%B8%E5%87%BA"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">2.1常见的逸出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%80%B8%E5%87%BA"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">静态逸出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#public%E4%BF%AE%E9%A5%B0get%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">public修饰get方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">1.4.2.1.3.</span> <span class="nav-text">方法参数传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#this%E9%80%B8%E5%87%BA"><span class="nav-number">1.4.2.1.4.</span> <span class="nav-text">this逸出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2.2安全发布对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.3.</span> <span class="nav-text">解决多线程遇到的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1%E7%AE%80%E8%BF%B0%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">3.1简述解决线程安全性的办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">3.2原子性和可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">3.2.1原子性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">3.2.2可见性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">3.3线程封闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4%E4%B8%8D%E5%8F%98%E6%80%A7"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">3.4不变性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%A7%94%E6%89%98"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">3.5线程安全性委托</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jean Lv"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jean Lv</p>
  <div class="site-description" itemprop="description">涉猎的主要编程语言Java、Python, 领域软件测试、AI测试开发相关</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jean Lv</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
