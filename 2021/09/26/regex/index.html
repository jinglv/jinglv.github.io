<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jinglv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="正则表达式学习">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式">
<meta property="og:url" content="https://jinglv.github.io/2021/09/26/regex/index.html">
<meta property="og:site_name" content="Jean&#39;s Blog">
<meta property="og:description" content="正则表达式学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201156044.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201157576.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201157310.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201158361.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201159859.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201200000.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201201604.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201201747.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201202142.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201203516.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201204716.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201205492.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201206270.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201208179.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201209733.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201210822.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201211169.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201212442.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201212153.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201213408.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201214481.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201217278.png">
<meta property="og:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201218562.png">
<meta property="article:published_time" content="2021-09-25T16:00:00.000Z">
<meta property="article:modified_time" content="2021-09-26T05:30:00.000Z">
<meta property="article:author" content="Jean Lv">
<meta property="article:tag" content="Regex">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201156044.png">

<link rel="canonical" href="https://jinglv.github.io/2021/09/26/regex/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>正则表达式 | Jean's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Jean's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jean's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注软件测试开发技术的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jinglv.github.io/2021/09/26/regex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jean Lv">
      <meta itemprop="description" content="涉猎的主要编程语言Java、Python, 领域软件测试、AI测试开发相关">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jean's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          正则表达式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-26 00:00:00 / 修改时间：13:30:00" itemprop="dateCreated datePublished" datetime="2021-09-26T00:00:00+08:00">2021-09-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Regex/" itemprop="url" rel="index"><span itemprop="name">Regex</span></a>
                </span>
            </span>

          
            <div class="post-description">正则表达式学习</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则是什么，能做什么？"><a href="#正则是什么，能做什么？" class="headerlink" title="正则是什么，能做什么？"></a>正则是什么，能做什么？</h2><p>正则，就是正则表达式，英文是 Regular Expression，简称 RE。顾名思义，正则其实就是一种<strong>描述文本内容组成规律的表示方式</strong></p>
<ul>
<li>在编程语言中，正则常常用来简化文本处理的逻辑</li>
<li>在 Linux 命令中，它也可以帮助我们轻松地查找或编辑文件的内容，甚至实现整个文件夹中所有文件的内容替换</li>
<li>在各种文本编辑器中，比如 Atom，Sublime Text 或 VS Code 等，在查找或替换的时候也会使用到它</li>
</ul>
<p>正则功能：</p>
<ul>
<li>校验数的的有效性，比如校验手机号、邮箱</li>
<li>查找符合要求的文本内容，比如查找符合某规则的号码</li>
<li>对文本进行切割、替换等操作，比如用连续的空白符切割</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://regex101.com/">正则练习地址</a></p>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><h4 id="元字符的概念"><a href="#元字符的概念" class="headerlink" title="元字符的概念"></a>元字符的概念</h4><p><strong>所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符</strong>，元字符是构成正则表达式的基本元件。正则就是由一系列的元字符组成的。</p>
<h4 id="正则元字符"><a href="#正则元字符" class="headerlink" title="正则元字符"></a>正则元字符</h4><h5 id="特殊单字符"><a href="#特殊单字符" class="headerlink" title="特殊单字符"></a>特殊单字符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>任意字符（换行除外）</td>
</tr>
<tr>
<td>\d</td>
<td>任意数字</td>
</tr>
<tr>
<td>\D</td>
<td>任意非数字</td>
</tr>
<tr>
<td>\w</td>
<td>任意字母数字下划线</td>
</tr>
<tr>
<td>\W</td>
<td>任意非字母数字下划线</td>
</tr>
<tr>
<td>\s</td>
<td>任意空白符</td>
</tr>
<tr>
<td>\S</td>
<td>任意非空白符</td>
</tr>
</tbody>
</table>
</div>
<h5 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\s</td>
<td>任意空白符</td>
</tr>
</tbody>
</table>
</div>
<h5 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h5><div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>0到多次</td>
</tr>
<tr>
<td>+</td>
<td>1到多次</td>
</tr>
<tr>
<td>?</td>
<td>0到1次</td>
</tr>
<tr>
<td>{m}</td>
<td>出现m次</td>
</tr>
<tr>
<td>{m,}</td>
<td>出现至少m次</td>
</tr>
<tr>
<td>{m,n}</td>
<td>m到n次</td>
</tr>
</tbody>
</table>
</div>
<h5 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h5><div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td></td>
<td>或，如ab\</td>
<td>cd代表ab或bc</td>
</tr>
<tr>
<td>[…]</td>
<td>多选一，括号中任意单个元素</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配a到z之间任意单个元素（按ASCII表，包含a，z）</td>
</tr>
<tr>
<td><sup><a href="#fn_..." id="reffn_...">...</a></sup></td>
<td>取反，不能是括号中的任意单个元素</td>
</tr>
</tbody>
</table>
</div>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><ol>
<li>第 1 位固定为数字 1；</li>
<li>第 2 位可能是 3，4，5，6，7，8，9；</li>
<li>第 3 位到第 11 位我们认为可能是 0-9 任意数字。</li>
</ol>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201156044.png" alt="image-20220720115600994"></p>
<h3 id="量词与贪婪"><a href="#量词与贪婪" class="headerlink" title="量词与贪婪"></a>量词与贪婪</h3><h4 id="量词-1"><a href="#量词-1" class="headerlink" title="量词"></a>量词</h4><p>用{m,n}来表示(*) (+) (?)这3种元字符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>同一表示方法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>{0,}</td>
<td>ab*<br />可以匹配a或abbb</td>
</tr>
<tr>
<td>+</td>
<td>{1,}</td>
<td>ab+<br />可以匹配ab或abbb，但不能匹配a</td>
</tr>
<tr>
<td>?</td>
<td>{0,1}</td>
<td>(<code>\</code>+86-)?\d{11}<br />可以匹配+86-13800001111或13800001111</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;a+&#x27;</span>, <span class="string">&#x27;aaaabbb&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;aaaa&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;a*&#x27;</span>, <span class="string">&#x27;aaaabbb&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>可以看出<code>(+)</code>和<code>(*)</code>的区别，<code>(*)</code>的结果匹配到了四次空字符串。为什么会匹配到空字符串呢？因为星号<code>(*)</code>代表0到多次，匹配0次就是空字符串。查看上面的结果，会发现疑问，aaaa这部分也是有空字符串的，为什么没匹配上呢？</p>
<p>对于以上问题，就引出贪婪与非贪婪模式，这两种模式都必须满足匹配次数的：</p>
<ul>
<li>贪婪模式，简单说就是尽可能进行最长匹配</li>
<li>非贪婪模式呢，则会尽可能进行最短匹配</li>
</ul>
<p>正是这两种模式产生了不同的匹配结果。</p>
<h4 id="贪婪、非贪婪与独占模式"><a href="#贪婪、非贪婪与独占模式" class="headerlink" title="贪婪、非贪婪与独占模式"></a>贪婪、非贪婪与独占模式</h4><h5 id="贪婪匹配（Greedy）"><a href="#贪婪匹配（Greedy）" class="headerlink" title="贪婪匹配（Greedy）"></a>贪婪匹配（Greedy）</h5><p>在正则中，表示次数的量词默认是贪婪的，在<strong>贪婪模式下，会尝试尽可能最大长度去匹配</strong>。</p>
<p>示例：字符串aaabb 中使用正则 a* 的匹配过程</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>aaabb</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>012345</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>开始</th>
<th>结束</th>
<th>说明</th>
<th>匹配内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1次</td>
<td>0</td>
<td>3</td>
<td>到第一个字母b发现不满足，输出aaa</td>
<td>aaa</td>
</tr>
<tr>
<td>第2次</td>
<td>3</td>
<td>3</td>
<td>匹配剩下的bb，发现匹配不上，输出空字符串</td>
<td>空字符串</td>
</tr>
<tr>
<td>第3次</td>
<td>4</td>
<td>4</td>
<td>匹配剩下的b，发现匹配不上，输出空字符串</td>
<td>空字符串</td>
</tr>
<tr>
<td>第4次</td>
<td>5</td>
<td>5</td>
<td>匹配剩下的空字符串，输出空字符串</td>
<td>空字符串</td>
</tr>
</tbody>
</table>
</div>
<p>a* 在匹配开头的 a 时，会尝试尽量匹配更多的 a，直到第一个字母 b 不满足要求为止，匹配上三个 a，后面每次匹配时都得到了空字符串。</p>
<p>贪婪模式的特点就是尽可能进行最大长度匹配。所以要不要使用贪婪模式是根据需求场景来定的。如果我们想尽可能最短匹配呢？那就要用到非贪婪匹配模式了。</p>
<h5 id="非贪婪匹配（Lazy）"><a href="#非贪婪匹配（Lazy）" class="headerlink" title="非贪婪匹配（Lazy）"></a>非贪婪匹配（Lazy）</h5><p>非贪婪模式会尽可能短地去匹配。那么如何将贪婪模式变成非贪婪模式呢？我们可以在量词后面加上英文的问号 (?)，正则就变成了 a*?。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;a*&#x27;</span>, <span class="string">&#x27;aaabb&#x27;</span>)  <span class="comment"># 贪婪模式</span></span><br><span class="line">[<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;a*?&#x27;</span>, <span class="string">&#x27;aaabb&#x27;</span>) <span class="comment"># 非贪婪模式</span></span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201157576.png" alt="image-20220720115705531"></p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201157310.png" alt="image-20220720115745264"></p>
<h5 id="独占模式（Possessive）"><a href="#独占模式（Possessive）" class="headerlink" title="独占模式（Possessive）"></a>独占模式（Possessive）</h5><p>独占模式不会交还已经匹配上的字符。</p>
<p>不管是贪婪模式，还是非贪婪模式，都需要发生<strong>回溯</strong>才能完成相应的功能。</p>
<p>什么是回溯呢？如下的例子，首先是贪婪模式：</p>
<ul>
<li>regex = “xy{1,3}z”</li>
<li>text = “xyyz”</li>
</ul>
<p>在匹配时，y{1,3}会尽可能长地去匹配，当匹配完 xyy 后，由于 y 要尽可能匹配最长，即三个，但字符串中后面是个 z 就会导致匹配不上，这时候正则就会向前回溯，吐出当前字符 z，接着用正则中的 z 去匹配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;xy&#123;1,3&#125;z&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;xyyz&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>匹配不上，回溯（即z会吐出来），在用z去匹配</p>
<p>正则为非贪婪模式：</p>
<ul>
<li>regex = “xy{1,3}?z”</li>
<li>text = “xyyz”</li>
</ul>
<p>由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会向前回溯，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;xy&#123;1,3&#125;?z&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;xyyz&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>正则z匹配不上，回溯，重新尝试匹配两个y的情况</p>
<p>但是在一些场景下，我们不需要回溯，匹配不上返回失败就好了，因此正则中还有另外一种模式，独占模式，它类似贪婪匹配，但匹配过程不会发生回溯，因此在一些场合下性能会更好。</p>
<p>独占模式和贪婪模式很像，独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯，这样的话就比较节省时间。具体的方法就是在量词后面加上加号（+）。</p>
<p>正则为独占模式：</p>
<ul>
<li>regex = “xy{1,3}+z”</li>
<li>text = “xyyz”</li>
</ul>
<p>需要注意的是 Python 和 Go 的标准库目前都不支持独占模式，会报错，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;xy&#123;1,3&#125;+yz&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>)</span><br><span class="line">error: multiple repeat at position <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>报错显示，加号（+）被认为是重复次数的元字符了。如果要测试这个功能，我们可以安装 PyPI 上的 regex 模块。</p>
<p>注意：需要先安装regex模块，python3 -m pip install regex</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> regex</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regex.findall(<span class="string">r&#x27;xy&#123;1,3&#125;z&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>) <span class="comment"># 贪婪模式[&#x27;xyyz&#x27;]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regex.findall(<span class="string">r&#x27;xy&#123;1,3&#125;+z&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>) <span class="comment"># 独占模式[&#x27;xyyz&#x27;]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regex.findall(<span class="string">r&#x27;xy&#123;1,2&#125;+yz&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>) <span class="comment"># 独占模式[]</span></span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>正则</th>
<th>文本</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>贪婪模式</td>
<td>a{1,3}ab</td>
<td>aaab</td>
<td>匹配</td>
</tr>
<tr>
<td>非贪婪模式</td>
<td>a{1,3}?ab</td>
<td>aaab</td>
<td>匹配</td>
</tr>
<tr>
<td>独占模式</td>
<td>a{1,3}+ab</td>
<td>aaab</td>
<td>不匹配</td>
</tr>
</tbody>
</table>
</div>
<p>独占模式性能比较好，可以节约匹配的时间和 CPU 资源，但有些情况下并不能满足需求，要想使用这个模式还要看具体需求，另外还得看你当前使用的语言或库的支持程度</p>
<p>正则中量词默认是贪婪匹配，如果想要进行非贪婪匹配需要在量词后面加上问号。贪婪和非贪婪匹配都可能会进行回溯，独占模式也是进行贪婪匹配，但不进行回溯，因此在一些场景下，可以提高匹配的效率，具体能不能用独占模式需要看使用的编程语言的类库的支持情况，以及独占模式能不能满足需求。</p>
<h4 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h4><p>有一篇英文文章，里面有很多单词，单词和单词之间是用空格隔开的，在引号里面的一到多个单词表示特殊含义，即引号里面的多个单词要看成一个单词。现在你需要提取出文章中所有的单词。我们可以假设文章中除了引号没有其它的标点符号，有什么方法可以解决这个问题呢？如果用正则来解决，你能不能写出一个正则，提取出文章中所有的单词呢（不要求结果去重）？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">we found “the little cat” is in the hat, we like “the little cat”</span><br></pre></td></tr></table></figure>
<p>注意：引号是中文情况下的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中 the little cat 需要看成一个单词</span><br></pre></td></tr></table></figure>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201158361.png" alt="image-20220720115843315"></p>
<h3 id="分组与引用"><a href="#分组与引用" class="headerlink" title="分组与引用"></a>分组与引用</h3><h4 id="分组与编号"><a href="#分组与编号" class="headerlink" title="分组与编号"></a>分组与编号</h4><p><strong>括号</strong>在正则中可以用于分组，被括号括起来的部分“子表达式”会被保存成一个子组。</p>
<p>分组和编号的规则：第几个括号就是第几个分组，如下的例子，这里有个时间格式 2020-05-10 20:23:05。假设我们想要使用正则提取出里面的日期和时间。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201159859.png" alt="image-20220720115929816"></p>
<p>正则表达式<code>(\d&#123;4&#125;-\d&#123;2&#125;-\&#123;2&#125;)(\d&#123;2&#125;:\d&#123;2&#125;:\&#123;2&#125;)</code>，将日期和时间都括号括起来。这个正则中一共有两个分组，日期是第 1 个，时间是第 2 个。</p>
<h4 id="不保存子组"><a href="#不保存子组" class="headerlink" title="不保存子组"></a>不保存子组</h4><p>在括号里面的会保存成子组，但有些情况下，你可能只想用括号将某些部分看成一个整体，后续不用再用它，类似这种情况，在实际使用时，是没必要保存子组的。这时我们可以在括号里面使用<code>?:</code>不保存子组。</p>
<p>如果正则中出现了括号，那么我们就认为，这个子表达式在后续可能会再次被引用，所以不保存子组可以提高正则的性能。除此之外呢，这么做还有一些好处，由于子组变少了，正则性能会更好，在子组计数时也更不容易出错。</p>
<p>不保存子组是什么？</p>
<ul>
<li>可以理解成，括号只用于归组，把某个部分当成“单个元素”，不分配编号，后面不会再进行这部分的引用。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>正则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>保存子组</td>
<td>(正则)</td>
<td><code>\d&#123;15&#125;(\d&#123;3&#125;)</code></td>
</tr>
<tr>
<td>不保存子组</td>
<td>(?:正则)</td>
<td><code>\d&#123;15&#125;(?:\d&#123;3&#125;)</code></td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201200000.png" alt="image-20220720120019952"></p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201201604.png" alt="image-20220720120108558"></p>
<h4 id="括号嵌套"><a href="#括号嵌套" class="headerlink" title="括号嵌套"></a>括号嵌套</h4><p>在括号嵌套的情况里，我们要看某个括号里面的内容是第几个分组怎么办？不要担心，其实方法很简单，我们只需要数左括号（开括号）是第几个，就可以确定是第几个子组。</p>
<p>例子：在阿里云简单日志系统中，我们可以使用正则来匹配一行日志的行首。假设时间格式是 2020-05-10 20:23:05 。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201201747.png" alt="image-20220720120140703"></p>
<p>日期分组编号是 1，时间分组编号是 5，年月日对应的分组编号分别是 2，3，4，时分秒的分组编号分别是 6，7，8。</p>
<h4 id="命名分组"><a href="#命名分组" class="headerlink" title="命名分组"></a>命名分组</h4><p>由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还可能导致编号发生变化，因此一些编程语言提供了命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为(?P&lt;分组名&gt;正则)。</p>
<p>比如在 Django 的路由中，命名分组示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^profile/(?P\w+)/$&#x27;</span>, view_func)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，刚刚提到的方式命名分组和前面一样，给这个分组分配一个编号，不过你可以使用名称，不用编号，实际上命名分组的编号已经分配好了。不过<strong>命名分组并不是所有语言都支持的</strong>，在使用时，你需要查阅所用语言正则说明文档，如果支持，那你才可以使用。</p>
<h4 id="分组引用"><a href="#分组引用" class="headerlink" title="分组引用"></a>分组引用</h4><p>在知道了分组引用的编号 （number）后，大部分情况下，我们就可以使用 “反斜扛 + 编号”，即 \number 的方式来进行引用，而 JavaScript 中是通过<code>$</code>编号来引用，如<code>$1</code>。</p>
<p>常见的编程语言中，分组查找和替换的引用方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编程语言</th>
<th>查找时引用方式</th>
<th>替换时引用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python</td>
<td>\number 如\1</td>
<td>\number 如\1</td>
</tr>
<tr>
<td>Go</td>
<td>官方包不支持</td>
<td>官方包不支持</td>
</tr>
<tr>
<td>Java</td>
<td>\number 如\1</td>
<td><code>$number</code>，如<code>$1</code></td>
</tr>
<tr>
<td>JavaScript</td>
<td>\number，如\1</td>
<td><code>$number</code>，如<code>$1</code></td>
</tr>
<tr>
<td>PHP</td>
<td>\number 如\1</td>
<td>\number 如\1</td>
</tr>
<tr>
<td>Ruby</td>
<td>\number 如\1</td>
<td>\number 如\1</td>
</tr>
</tbody>
</table>
</div>
<h4 id="分组引用在查找中使用"><a href="#分组引用在查找中使用" class="headerlink" title="分组引用在查找中使用"></a>分组引用在查找中使用</h4><p>正则查找时如何使用分组引用?。比如我们要找重复出现的单词，我们使用正则可以很方便地使“前面出现的单词再次出现”，具体要怎么操作呢？我们可以使用 \w+ 来表示一个单词，针对刚刚的问题，我们就可以很容易写出 (\w+) \1 这个正则表达式了。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201202142.png" alt="image-20220720120232095"></p>
<h4 id="分组引用在替换中使用"><a href="#分组引用在替换中使用" class="headerlink" title="分组引用在替换中使用"></a>分组引用在替换中使用</h4><p>和查找类似，我们可以使用反向引用，在得到的结果中，去拼出来我们想要的结果。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201203516.png" alt="image-20220720120315469"></p>
<p>Python3的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_str=<span class="string">&quot;2020-08-18 12:02:05&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regex=<span class="string">r&quot;((\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)) ((\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;))&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>subst=<span class="string">r&quot;日期\1 时间\5 \2年\3月\4日 \6时\7分\8秒&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(regex, subst, test_str)</span><br><span class="line"><span class="string">&#x27;日期2020-08-18 时间12:02:05 2020年08月18日 12时02分05秒&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h4><p>有一篇英文文章，里面有一些单词连续出现了多次，我们认为连续出现多次的单词应该是一次，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the little cat cat is in the hat hat hat, we like it.</span><br></pre></td></tr></table></figure>
<p>其中 cat 和 hat 连接出现多次，要求处理后结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the little cat is in the hat, we like it.</span><br></pre></td></tr></table></figure>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201204716.png" alt="image-20220720120414672"></p>
<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>所谓匹配模式，指的是正则中一些<strong>改变元字符匹配行为</strong>的方式，比如匹配时不区分英文字母大小写。常见的匹配模式有 4 种，分别是不区分大小写模式、点号通配模式、多行模式和注释模式。</p>
<h4 id="不区分大小写模式（Case-Insensitive）"><a href="#不区分大小写模式（Case-Insensitive）" class="headerlink" title="不区分大小写模式（Case-Insensitive）"></a>不区分大小写模式（Case-Insensitive）</h4><p>一个例子：在进行文本匹配时，我们要关心单词本身的意义。比如要查找单词 cat，我们并不需要关心单词是 CAT、Cat，还是 cat。根据之前我们学到的知识，你可能会把正则写成这样：<code>[Cc][Aa][Tt]</code>，这样写虽然可以达到目的，但不够直观，如果单词比较长，写起来容易出错，阅读起来也比较困难。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201205492.png" alt="image-20220720120552441"></p>
<p>不区分大小写是匹配模式的一种。当我们把模式修饰符放在整个正则前面时，就表示整个正则表达式都是不区分大小写的。模式修饰符是通过 (? 模式标识) 的方式来表示的。 我们只需要把模式修饰符放在对应的正则前，就可以使用指定的模式了。在不区分大小写模式中，由于不分大小写的英文是 Case-Insensitive，那么对应的模式标识就是 I 的小写字母 i，所以不区分大小写的 cat 就可以写成 (?i)cat。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201206270.png" alt="image-20220720120655221"></p>
<p><code>(?i)cat</code>相比<code>[Cc][Aa][Tt]</code>清晰简洁的很多了。</p>
<p>也可以用它来尝试匹配两个连续出现的 cat，如下图所示，你会发现，即便是第一个cat和第二个cat大小写不一致，也可以匹配上。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201208179.png" alt="image-20220720120831126"></p>
<p>如果想要第一次和第二次重复时的大小写一致，只需要用括号把<strong>修饰符和正则cat部分</strong>括起来，加括号相当于作用范围的限定，让不区分大小写只作用于这个括号里的内容。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201209733.png" alt="image-20220720120935677"></p>
<p>需要注意的是，这里正则写成了<code>((?i)cat) \1</code>，而不是<code>((?i)(cat)) \1</code>。也就是说，我们给修饰符和 cat 整体加了个括号，而原来 cat 部分的括号去掉了。如果 cat 保留原来的括号，即<code>((?i)(cat)) \1</code>，这样正则中就会有两个子组，虽然结果也是对的，但这其实没必要。</p>
<p>如果用正则匹配，实现部分区分大小写，另一部分不区分大小写，这该如何操作呢？就比如说我现在想要，the cat 中的 the 不区分大小写，cat 区分大小写。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201210822.png" alt="image-20220720121021766"></p>
<p>有一点需要你注意一下，上面讲到的通过修饰符指定匹配模式的方式，在大部分编程语言中都是可以直接使用的，但在 JS 中我们需要使用 /regex/i 来指定匹配模式。在编程语言中通常会提供一些预定义的常量，来进行匹配模式的指定。比如 Python 中可以使用 re.IGNORECASE 或 re.I ，来传入正则函数中来表示不区分大小写。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import re</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.findall(r<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;CAT Cat cat&quot;</span>, re.IGNORECASE)</span></span><br><span class="line">[&#x27;CAT&#x27;, &#x27;Cat&#x27;, &#x27;cat&#x27;]</span><br></pre></td></tr></table></figure>
<p>总结一下不区分大小写模式的要点：</p>
<ol>
<li><p>不区分大小写模式的指定方式，使用模式修饰符 (?i)；</p>
</li>
<li><p>修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则；</p>
</li>
<li><p>使用编程语言时可以使用预定义好的常量来指定匹配模式。</p>
</li>
</ol>
<h4 id="点号通配模式（Dot-All）"><a href="#点号通配模式（Dot-All）" class="headerlink" title="点号通配模式（Dot All）"></a>点号通配模式（Dot All）</h4><p><code>.任意字符（换行除外）</code>可以匹配上任何符号，但不能匹配换行。当我们需要匹配真正的“任意”符号的时候，可以使用 [\s\S] 或 [\d\D] 或 [\w\W] 等。但这么写不够简洁自然，所以正则中提供了一种模式，让英文的点（.）可以匹配上包括换行的任何字符。</p>
<p>模式就是<strong>点号通配模式</strong>，有很多地方把它称作<strong>单行匹配模式</strong></p>
<p>单行的英文表示是 Single Line，单行模式对应的修饰符是<code>(?s)</code></p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201211169.png" alt="image-20220720121110111"></p>
<p>点可以匹配上换行</p>
<p>需要注意的是，JavasScript 不支持此模式，那么我们就可以使用前面说的[\s\S]等方式替代。在 Ruby 中则是用 Multiline，来表示点号通配模式（单行匹配模式）。</p>
<h4 id="多行匹配模式（Multiline）"><a href="#多行匹配模式（Multiline）" class="headerlink" title="多行匹配模式（Multiline）"></a>多行匹配模式（Multiline）</h4><p>通常情况下，<code>^匹配整个字符串的开头，$ 匹配整个字符串的结尾。多行匹配模式改变的就是 ^ 和 $ 的匹配行为</code>。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201212442.png" alt="image-20220720121208384"></p>
<p>多行模式的作用在于，使 ^ 和 $ 能匹配上<strong>每行</strong>的开头或结尾，我们可以使用模式修饰符号<code>(?m)</code>来指定这个模式</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201212153.png" alt="image-20220720121254093"></p>
<p>和以下好像没有差</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201213408.png" alt="image-20220720121335350"></p>
<p>这个模式有什么用呢？在处理日志时，如果日志以时间开头，有一些日志打印了堆栈信息，占用了多行，我们就可以使用多行匹配模式，在日志中匹配到以时间开头的每一行日志。</p>
<p>值得一提的是，正则中还有 \A 和 \z（Python 中是 \Z） 这两个元字符容易混淆，\A 仅匹配整个字符串的开始，\z 仅匹配整个字符串的结束，在多行匹配模式下，它们的匹配行为不会改变，如果只想匹配整个字符串，而不是匹配每一行，用这个更严谨一些。</p>
<h4 id="注释模式（Comment）"><a href="#注释模式（Comment）" class="headerlink" title="注释模式（Comment）"></a>注释模式（Comment）</h4><p>在实际工作中，正则可能会很复杂，这就导致编写、阅读和维护正则都会很困难。我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。很多语言也支持在正则中添加注释，让正则更容易阅读和维护，这就是正则的注释模式。正则中注释模式是使用 <code>(?#comment)</code> 来表示。</p>
<p>比如我们可以把单词重复出现一次的正则 (\w+) \1 写成下面这样，这样的话，就算不是很懂正则的人也可以通过注释看懂正则的意思。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\w+)(?#word) \1(?#word repeat again)</span><br></pre></td></tr></table></figure>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201214481.png" alt="image-20220720121425424"></p>
<p>在很多编程语言中也提供了 x 模式来书写正则，也可以起到注释的作用。Python3的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">regex = <span class="string">r&#x27;&#x27;&#x27;(?mx) #使用多行模式和x模式</span></span><br><span class="line"><span class="string">^   # 开头</span></span><br><span class="line"><span class="string">(\d&#123;4&#125;) # 年</span></span><br><span class="line"><span class="string">(\d&#123;2&#125;) # 月</span></span><br><span class="line"><span class="string">$   # 结尾</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(re.findall(regex, <span class="string">&#x27;202007\n202008&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：[(&#x27;2020&#x27;, &#x27;07&#x27;), (&#x27;2020&#x27;, &#x27;08&#x27;)]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是在 x 模式下，所有的换行和空格都会被忽略。为了换行和空格的正确使用，我们可以通过把空格放入字符组中，或将空格转义来解决换行和空格的忽略问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">regex = <span class="string">r&#x27;&#x27;&#x27;(?mx) #使用多行模式和x模式</span></span><br><span class="line"><span class="string">^   # 开头</span></span><br><span class="line"><span class="string">(\d&#123;4&#125;) # 年</span></span><br><span class="line"><span class="string">[ ] # 空格</span></span><br><span class="line"><span class="string">(\d&#123;2&#125;) # 月</span></span><br><span class="line"><span class="string">$   # 结尾</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(re.findall(regex, <span class="string">&#x27;2020 07\n2020 08&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：[(&#x27;2020&#x27;, &#x27;07&#x27;), (&#x27;2020&#x27;, &#x27;08&#x27;)]</span></span><br></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>正则中常见的四种匹配模式，分别是：不区分大小写、点号通配模式、多行模式和注释模式。</p>
<ol>
<li>不区分大小写模式，它可以让整个正则或正则中某一部分进行不区分大小写的匹配。</li>
<li>点号通配模式也叫单行匹配，改变的是点号的匹配行为，让其可以匹配任何字符，包括换行。</li>
<li>多行匹配说的是 ^ 和 $ 的匹配行为，让其可以匹配上每行的开头或结尾。</li>
<li>注释模式则可以在正则中添加注释，让正则变得更容易阅读和维护。</li>
</ol>
<h2 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h2><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>如何用断言更好地实现替换重复出现的单词？</p>
<p>什么是断言呢？<strong>断言</strong>是指匹配到文本位置有要求。</p>
<p>举例讲解。例如<code>\d&#123;11&#125;</code>能匹配上11位数字，但这11位数字可能是18位身份证号中的一部分。再例如，我们要查找tom，但其它单词，比如tomorrow中也包含了tom。</p>
<p>从上面的例子看到，在有些情况下，我们对需要匹配的文本的位置是有一定要求的。为了解决这个问题，正则中提供了一些结构，只用于匹配位置，而不是文本内容本身，这种结构就是断言。</p>
<p>常见的断言有三种：<strong>单词边界</strong>、<strong>行的开始或结束</strong>、<strong>环视</strong>。</p>
<h4 id="单词边界（Word-Boundary）"><a href="#单词边界（Word-Boundary）" class="headerlink" title="单词边界（Word Boundary）"></a>单词边界（Word Boundary）</h4><p>举例，我们需要将下面文本中的tom替换成jerry。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tom asked me if I would go fishing with him tomorrow.(Tom 问我明天能否和他一同去钓鱼)</span><br></pre></td></tr></table></figure>
<p> 注意一下，在文本中出现了 tomorrow 这个单词，tomorrow 也是以 tom 开头的。</p>
<p>如果直接替换，就会出现如下的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_str = <span class="string">&quot;tom asked me if I would go fishing with him tomorrow.&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;tom&#x27;</span>, <span class="string">r&quot;jerry&quot;</span>, test_str)</span><br><span class="line"><span class="string">&#x27;jerry asked me if I would go fishing with him jerryorrow.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这显然是错误的，因为明天这个英语单词里面的 tom 也被替换了。</p>
<p>那正则是如何解决这个问题的呢？单词的组成一般可以用元字符 \w+ 来表示，\w 包括了大小写字母、下划线和数字（即 [A-Za-z0-9_]）。那如果我们能找出单词的边界，也就是当出现了\w 表示的范围以外的字符，比如引号、空格、标点、换行等这些符号，我们就可以在正则中使用\b 来表示单词的边界。 \b 中的 b 可以理解为是边界（Boundary）这个单词的首字母。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>tom单词包含tom</th>
<th><code>\btom</code>以tom开头的单词</th>
<th><code>tom\b</code>以tom结尾的单词</th>
<th><code>\btom\b</code>只能是tom</th>
</tr>
</thead>
<tbody>
<tr>
<td>tom</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>tomorrow</td>
<td>✅</td>
<td>✅</td>
<td>❎</td>
<td>❎</td>
</tr>
<tr>
<td>atom</td>
<td>✅</td>
<td>❎</td>
<td>✅</td>
<td>❎</td>
</tr>
<tr>
<td>atomic</td>
<td>✅</td>
<td>❎</td>
<td>❎</td>
<td>❎</td>
</tr>
</tbody>
</table>
</div>
<p>根据刚刚学到的内容，在准确匹配单词时，我们使用 \b\w+\b 就可以实现了。</p>
<p>经过改进后的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_str = <span class="string">&quot;tom asked me if I would go fishing with him tomorrow.&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;\btom\b&#x27;</span>, <span class="string">r&quot;jerry&quot;</span>, test_str)</span><br><span class="line"><span class="string">&#x27;jerry asked me if I would go fishing with him tomorrow.&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="行的开始或结束"><a href="#行的开始或结束" class="headerlink" title="行的开始或结束"></a>行的开始或结束</h4><p>和单词的边界类似，在正则中还有文本每行的开始和结束，如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用<code>^</code> 和 <code>$</code>来进行位置界定。</p>
<p>我们先说一下行的结尾是如何判断的。你应该知道换行符号。在计算机中，回车（\r）和换行（\n）其实是两个概念，并且在不同的平台上，换行的表示也是不一样的。看下 Windows、Linux、macOS 平台上换行的表示方式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>平台</th>
<th>换行符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td><code>\r\n</code></td>
</tr>
<tr>
<td>Linux</td>
<td><code>\n</code></td>
</tr>
<tr>
<td>macOS</td>
<td><code>\n</code></td>
</tr>
</tbody>
</table>
</div>
<p>匹配行的开始和结束有什么用呢？</p>
<h5 id="日志的起始行判断"><a href="#日志的起始行判断" class="headerlink" title="日志的起始行判断"></a>日志的起始行判断</h5><p>最常见的例子就是日志收集，我们在收集日志的时候，通常可以指定日志行的开始规则，比如以时间开头，那些不是以时间开头的可能就是打印的堆栈信息。我来给你一个以日期开头，下面每一行都属于同一篇日志的例子。</p>
<h5 id="输入数据校验"><a href="#输入数据校验" class="headerlink" title="输入数据校验"></a>输入数据校验</h5><p>在 Web 服务中，我们常常需要对输入的内容进行校验，比如要求输入 6 位数字，我们可以使用<code>\d&#123;6&#125;</code>来校验。但你需要注意到，如果用户输入的是 6 位以上的数字呢？在这种情况下，如果不去要求用户录入的 6 位数字必须是行的开头或结尾，就算验证通过了，结果也可能不对。比如下面的示例，在不加行开始和结束符号时，用户输入了 7 位数字，也是能校验通过的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 能匹配上 (包含6位数字)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">&#x27;\d&#123;6&#125;&#x27;</span>, <span class="string">&#x27;1234567&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 能匹配上 (以6位数字开头)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">&#x27;^\d&#123;6&#125;&#x27;</span>, <span class="string">&#x27;1234567&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 能匹配上 (以6位数字结尾)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">&#x27;\d&#123;6&#125;$&#x27;</span>, <span class="string">&#x27;1234567&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 不能匹配上 (只能是6位数字)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">&#x27;^\d&#123;6&#125;$&#x27;</span>, <span class="string">&#x27;1234567&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment"># 能匹配上 (只能是6位数字)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">&#x27;^\d&#123;6&#125;$&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>在多行模式下，<code>^</code>和 <code>$</code> 符号可以匹配每一行的开头或结尾。大部分实现默认不是多行匹配模式，但也有例外，比如 Ruby 中默认是多行模式。所以对于校验输入数据来说，一种更严谨的做法是，使用 <code>\A</code> 和 <code>\z</code> （Python 中使用 <code>\Z</code>） 来匹配整个文本的开头或结尾。</p>
<p>解决这个问题还有一种做法，我们可以在使用正则校验前，先判断一下字符串的长度，如果不满足长度要求，那就不需要再用正则去判断了。相当于你用正则解决主要的问题，而不是所有问题，这也是说使用正则要克制。</p>
<h4 id="环视（-Look-Around）"><a href="#环视（-Look-Around）" class="headerlink" title="环视（ Look Around）"></a>环视（ Look Around）</h4><p>环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，有些地方也称环视为<strong>零宽断言</strong>。</p>
<p>那具体什么时候我们会用到环视呢？我来举个例子。邮政编码的规则是由 6 位数字组成。现在要求你写出一个正则，提取文本中的邮政编码。根据规则，我们很容易就可以写出邮编的组成\d{6}。我们可以使用下面的文本进行测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">130400</span> 满足要求</span><br><span class="line"><span class="number">465441</span> 满足要求</span><br><span class="line"><span class="number">4654000</span> 长度过长</span><br><span class="line"><span class="number">138001380002</span> 长度过长</span><br></pre></td></tr></table></figure>
<p>使用<code>\d&#123;6&#125;</code>，会发现7位数的前6位也能匹配上，12位数匹配上了两次，这显然是不符合要求的。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201217278.png" alt="image-20220720121726227"></p>
<p>也就是说，除了文本本身组成符合这 6 位数的规则外，这 6 位数左边或右边都不能是数字。</p>
<p>正则是通过环视来解决这个问题的。解决这个问题的正则有四种。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>正则</th>
<th>名称</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(?&lt;=Y)</code></td>
<td>肯定逆序环视postive-lookbehind</td>
<td>左边是Y</td>
<td><code>(?&lt;=\d)th</code>左边是数字的th，能匹配9th</td>
</tr>
<tr>
<td><code>(?&lt;!Y)</code></td>
<td>否定逆序环视negative-lookbehind</td>
<td>左边不是Y</td>
<td><code>(?&lt;=!\d)th</code>左边不是数字的th，能匹配health</td>
</tr>
<tr>
<td><code>(?=Y)</code></td>
<td>肯定顺序环视postive-lookahead</td>
<td>右边是Y</td>
<td><code>six(?=\d)</code>右边是数字的six，能匹配six6</td>
</tr>
<tr>
<td><code>(?!Y)</code></td>
<td>否定顺序环视negative-lookahead</td>
<td>右边不是Y</td>
<td><code>hi(?!\d)</code>右边不是数字的hi，能匹配high</td>
</tr>
</tbody>
</table>
</div>
<p>便于记忆的小口诀，<strong>左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思</strong>。</p>
<p>因此，针对刚刚邮编的问题，就可以写成左边不是数字，右边也不是数字的 6 位数的正则。即<code>(?&lt;!\d)\d&#123;6&#125;(?!\d)</code>。这样就能符合要求了。</p>
<p><img src="https://jing-images.oss-cn-beijing.aliyuncs.com/img/202207201218562.png" alt="image-20220720121802517"></p>
<h5 id="单词边界用环视表示"><a href="#单词边界用环视表示" class="headerlink" title="单词边界用环视表示"></a>单词边界用环视表示</h5><p>表示单词边界的 \b 如果用环视的方式来写，应该是怎么写呢？</p>
<p>这个问题其实比较简单，单词可以用 <code>\w+</code> 来表示，单词的边界其实就是那些不能组成单词的字符，即左边和右边都不能是组成单词的字符。比如下面这句话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the little cat is in the hat</span><br></pre></td></tr></table></figure>
<p>the 左侧是行首，右侧是空格，hat 右侧是行尾，左侧是空格，其它单词左右都是空格。所有单词左右都不是<code>\w</code>。</p>
<p><code>(?&lt;!\w)</code>表示左边不能是单词组成字符，<code>(?!\w)</code>右边不能是单词组成字符，即<code>\b\w+\b</code>也可以写成<code>(?&lt;!\w)\w+(?!\w)</code>。</p>
<p>也可以根据<strong>非</strong><code>\w</code>也可以用<code>\W</code>来表示。那单词的正则可以写成<code>(?&lt;=\W)\w+(?=\W)</code>。</p>
<p>这个例子只是加强思考，并不在日常工作中这么来表示单词的边界，因为<code>\b</code>明显更简洁，也更容易阅读和书写。</p>
<h5 id="环视和子组"><a href="#环视和子组" class="headerlink" title="环视和子组"></a>环视和子组</h5><p>之前有讲过”分组与引用”相关的内容，环视中虽然也有括号，但不会保存子组。保存成子组的一般是匹配到的文本内容，后续用于替换等操作，而环视是表示对文本左右环境的要求，即环视只匹配位置，不匹配文本内容。</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>正则中转义需要注意哪些问题？</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Regex/" rel="tag"># Regex</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/26/service/" rel="prev" title="阿里云服务相关配置搭建">
      <i class="fa fa-chevron-left"></i> 阿里云服务相关配置搭建
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/26/hello-hexo/" rel="next" title="Hexo搭建个人博客并部署到Github">
      Hexo搭建个人博客并部署到Github <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">正则是什么，能做什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="nav-number">1.2.</span> <span class="nav-text">基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.1.</span> <span class="nav-text">元字符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">元字符的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E5%85%83%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">正则元字符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%8D%95%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">特殊单字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E7%99%BD%E7%AC%A6"><span class="nav-number">1.2.1.2.2.</span> <span class="nav-text">空白符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8F%E8%AF%8D"><span class="nav-number">1.2.1.2.3.</span> <span class="nav-text">量词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4"><span class="nav-number">1.2.1.2.4.</span> <span class="nav-text">范围</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">练习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8F%E8%AF%8D%E4%B8%8E%E8%B4%AA%E5%A9%AA"><span class="nav-number">1.2.2.</span> <span class="nav-text">量词与贪婪</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8F%E8%AF%8D-1"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">量词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AA%E5%A9%AA%E3%80%81%E9%9D%9E%E8%B4%AA%E5%A9%AA%E4%B8%8E%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">贪婪、非贪婪与独占模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%EF%BC%88Greedy%EF%BC%89"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">贪婪匹配（Greedy）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%EF%BC%88Lazy%EF%BC%89"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">非贪婪匹配（Lazy）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F%EF%BC%88Possessive%EF%BC%89"><span class="nav-number">1.2.2.2.3.</span> <span class="nav-text">独占模式（Possessive）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.2.2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-1"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">练习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">分组与引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%B8%8E%E7%BC%96%E5%8F%B7"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">分组与编号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E4%BF%9D%E5%AD%98%E5%AD%90%E7%BB%84"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">不保存子组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E5%B5%8C%E5%A5%97"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">括号嵌套</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%88%86%E7%BB%84"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">命名分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">分组引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%BC%95%E7%94%A8%E5%9C%A8%E6%9F%A5%E6%89%BE%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">分组引用在查找中使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%BC%95%E7%94%A8%E5%9C%A8%E6%9B%BF%E6%8D%A2%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.3.7.</span> <span class="nav-text">分组引用在替换中使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-2"><span class="nav-number">1.2.3.8.</span> <span class="nav-text">练习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.4.</span> <span class="nav-text">匹配模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E6%A8%A1%E5%BC%8F%EF%BC%88Case-Insensitive%EF%BC%89"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">不区分大小写模式（Case-Insensitive）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%B9%E5%8F%B7%E9%80%9A%E9%85%8D%E6%A8%A1%E5%BC%8F%EF%BC%88Dot-All%EF%BC%89"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">点号通配模式（Dot All）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%EF%BC%88Multiline%EF%BC%89"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">多行匹配模式（Multiline）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E6%A8%A1%E5%BC%8F%EF%BC%88Comment%EF%BC%89"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">注释模式（Comment）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%AF%87"><span class="nav-number">1.3.</span> <span class="nav-text">应用篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80"><span class="nav-number">1.3.1.</span> <span class="nav-text">断言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C%EF%BC%88Word-Boundary%EF%BC%89"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">单词边界（Word Boundary）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E7%9A%84%E5%BC%80%E5%A7%8B%E6%88%96%E7%BB%93%E6%9D%9F"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">行的开始或结束</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E8%B5%B7%E5%A7%8B%E8%A1%8C%E5%88%A4%E6%96%AD"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">日志的起始行判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="nav-number">1.3.1.2.2.</span> <span class="nav-text">输入数据校验</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E8%A7%86%EF%BC%88-Look-Around%EF%BC%89"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">环视（ Look Around）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C%E7%94%A8%E7%8E%AF%E8%A7%86%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">单词边界用环视表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8E%AF%E8%A7%86%E5%92%8C%E5%AD%90%E7%BB%84"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">环视和子组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">转义</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jean Lv"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jean Lv</p>
  <div class="site-description" itemprop="description">涉猎的主要编程语言Java、Python, 领域软件测试、AI测试开发相关</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jean Lv</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
